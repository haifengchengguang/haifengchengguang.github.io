<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://haifengchengguang.github.io</id>
    <title>hrefen</title>
    <updated>2023-03-06T08:38:52.227Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://haifengchengguang.github.io"/>
    <link rel="self" href="https://haifengchengguang.github.io/atom.xml"/>
    <subtitle>我很弱，但是我要坚强！绝不让那些为我付出过的人失望！
</subtitle>
    <logo>https://haifengchengguang.github.io/images/avatar.png</logo>
    <icon>https://haifengchengguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, hrefen</rights>
    <entry>
        <title type="html"><![CDATA[面向对象编程导论学习]]></title>
        <id>https://haifengchengguang.github.io/post/mian-xiang-dui-xiang-bian-cheng-dao-lun-xue-xi/</id>
        <link href="https://haifengchengguang.github.io/post/mian-xiang-dui-xiang-bian-cheng-dao-lun-xue-xi/">
        </link>
        <updated>2021-06-22T06:47:08.000Z</updated>
        <content type="html"><![CDATA[<p align="right">edit at 3/7/2021</p>
<h1 id="面向对象与uml图">面向对象与uml图</h1>
<p>类<br>
根据抽象的原则对客观事物进行归纳和划分，只关注与当前目标相关的特征，把具有相同特征的事物归为一个类。它是一个抽象的概念。<br>
类是具有相同属性和相同操作（服务）的对象的集合。它包括属性和操作。</p>
<p>对象</p>
<p>对象是独立存在的客观事物，它由一组属性和一组操作构成。<br>
属性和操作是对象的两大要素。属性是对象静态特征的描述，操作是对象动态特征的描述。<br>
属性一般只能通过执行对象的操作来改变。<br>
操作又称为方法或服务，它描述了对象执行的功能。通过消息传递，还可以为其它对象使用</p>
<p>每一个对象都是某个类的实例。类是一组相似的对象 。<br>
类是对象相关行为的储存库(repository)。即同一个类的所有对象都能执行同样的动作。</p>
<p>OOP定义-Alan Kay</p>
<p>OOP是基于递归设计的原则的：<br>
一切都是对象。<br>
计算通过对象间相互通信，请求其他对象执行动作来实现。对象间通过发送和接收消息来通信。<br>
每个对象都有自己的内存，其中可能包括了其他的对象。<br>
每一个对象都是某个类的实例。类就是一组相似的对象。<br>
类是对象相关行为的储存库。也就是说，同一个类的所有对象都能执行同样的动作。<br>
类被组织成有单个根节点的树状结构，被称为继承层次结构。与类实例相关的内存和行为都会被树结构中的后代自动继承。</p>
<p>对象间通信</p>
<p>向前定义<br>
多个互相引用的类(相互递归)<br>
Java全文扫描。C++向前定义</p>
<p>内部类(嵌套类)<br>
在一个类中定义另外一个类。(Java内部类。C++嵌套类)<br>
语义差别<br>
Java内部类被连接到外部类的具体实例上，并且允许存取其实例和方法。C++仅是命名手段，限制和内部类相关的特征可视性。<br>
java的非静态内部类有个外部类的引用outer，使用这个变量可以引用外部的所有变量，包括private<br>
静态的java内部类也叫做嵌套类，静态的内部类就没有外部的引用了，但是也只能调用外部的静态方法和变量<br>
c++的内部类几乎等同于语法上的嵌套,而C++的内部类不能访问外部类的private变量，想访问的话必须在内部类中声明外部类为friend class<br>
Java 内部类<br>
Java 对象和类<br>
在章节我们将来学习 Java 的内部类。<br>
Java 一个类中可以嵌套另外一个类，语法格式如下：<br>
class OuterClass {   // 外部类<br>
// ...<br>
class NestedClass { // 嵌套类，或称为内部类<br>
// ...<br>
}<br>
}<br>
要访问内部类，可以通过创建外部类的对象，然后创建内部类的对象来实现。<br>
嵌套类有两种类型：<br>
•	非静态内部类<br>
•	静态内部类<br>
非静态内部类<br>
非静态内部类是一个类中嵌套着另外一个类。 它有访问外部类成员的权限， 通常被称为内部类。<br>
由于内部类嵌套在外部类中，因此必须首先实例化外部类，然后创建内部类的对象来实现。<br>
实例<br>
class OuterClass {<br>
int x = 10;</p>
<p>class InnerClass {<br>
int y = 5;<br>
}<br>
}</p>
<p>public class MyMainClass {<br>
public static void main(String[] args) {<br>
OuterClass myOuter = new OuterClass();<br>
OuterClass.InnerClass myInner = myOuter.new InnerClass();<br>
System.out.println(myInner.y + myOuter.x);<br>
}<br>
}<br>
以上实例执行输出结果为：<br>
15<br>
私有的内部类<br>
内部类可以使用 private 或 protected 来修饰，如果你不希望内部类被外部类访问可以使用 private 修饰符：<br>
实例<br>
class OuterClass {<br>
int x = 10;</p>
<p>private class InnerClass {<br>
int y = 5;<br>
}<br>
}</p>
<p>public class MyMainClass {<br>
public static void main(String[] args) {<br>
OuterClass myOuter = new OuterClass();<br>
OuterClass.InnerClass myInner = myOuter.new InnerClass();<br>
System.out.println(myInner.y + myOuter.x);<br>
}<br>
}<br>
以上实例 InnerClass 设置为私有内部类，执行会报错：<br>
MyMainClass.java:12: error: OuterClass.InnerClass has private access in OuterClass<br>
OuterClass.InnerClass myInner = myOuter.new InnerClass();<br>
^<br>
静态内部类<br>
静态内部类可以使用 static 关键字定义，静态内部类我们不需要创建外部类来访问，可以直接访问它：<br>
实例<br>
class OuterClass {<br>
int x = 10;</p>
<p>static class InnerClass {<br>
int y = 5;<br>
}<br>
}</p>
<p>public class MyMainClass {<br>
public static void main(String[] args) {<br>
OuterClass.InnerClass myInner = new OuterClass.InnerClass();<br>
System.out.println(myInner.y);<br>
}<br>
}<br>
以上实例执行输出结果为：<br>
5<br>
注意：静态内部类无法访问外部类的成员。<br>
从内部类访问外部类成员<br>
内部类一个高级的用法就是可以访问外部类的属性和方法：<br>
实例<br>
class OuterClass {<br>
int x = 10;</p>
<p>class InnerClass {<br>
public int myInnerMethod() {<br>
return x;<br>
}<br>
}<br>
}</p>
<p>public class MyMainClass {<br>
public static void main(String[] args) {<br>
OuterClass myOuter = new OuterClass();<br>
OuterClass.InnerClass myInner = myOuter.new InnerClass();<br>
System.out.println(myInner.myInnerMethod());<br>
}<br>
}<br>
以上实例执行输出结果为：<br>
10</p>
<p>通过指定方法的访问级别（例如 public 或private）、可选修饰符（例如abstract 或sealed）、返回值、名称和任何方法参数，可以在类或 结构中声明方法。<br>
为进行方法重载，方法的返回类型不是方法签名的一部分。<br>
先来看几个概念：<br>
重载(overload)，重写(override,也称覆盖), 重定义(redefine,也称隐藏)<br>
(PS:第三个我不确定在英文中是否应该称为redefine，如有问题，留言告知，谢谢)<br>
一、重载（overload）<br>
指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。<br>
（1）相同的范围（在同一个作用域中） ；<br>
（2）函数名字相同；<br>
（3）参数不同；<br>
（4）virtual 关键字可有可无。<br>
（5）返回值可以不同；<br>
二、重写（也称为覆盖 override）<br>
是指派生类重新定义基类的虚函数，特征是：<br>
（1）不在同一个作用域（分别位于派生类与基类） ；<br>
（2）函数名字相同；<br>
（3）参数相同；<br>
（4）基类函数必须有 virtual 关键字，不能有 static 。<br>
（5）返回值相同（或是协变），否则报错；&lt;—-协变这个概念我也是第一次才知道…<br>
（6）重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的<br>
三、重定义（也成隐藏）<br>
（1）不在同一个作用域（分别位于派生类与基类） ；<br>
（2）函数名字相同；<br>
（3）返回值可以不同；<br>
（4）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆） 。<br>
（5）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 。</p>
<h1 id="经典java题">经典java题</h1>
<pre><code class="language-java">class B{
    public B(){
        System.out.print(&quot;B!\t&quot;);
    }
    public void f(double d){
        g(d);
    }
    public void g(int i){
        System.out.println(&quot;g(int &quot;+i+&quot;) in B!&quot;);
    }
    public void g(double d){
        System.out.println(&quot;g(double &quot;+d+&quot;) in B!&quot;);
    }
}
class C extends B{
    public C(int i){
        System.out.println(&quot;Constructor: &quot; + i);
    }
    public void f(int i){
        g(i);
    }
    public void g(double d){
        System.out.println(&quot;g(double &quot;+d+&quot;) in C!&quot;);
    }
}
public class E24 {
    public static void main(String[] args){
        //父类 对象名=new 子类（）只能调用父类的函数，不能调用子类的函数，因为它没有继承
        //子类new子类，可以调用父类的函数也可以调用子类的函数
        B obj1=new C(1);//父类new子类，先调用父类方法，父类方法被重写则用子类方法
        obj1.f(2);//调用父类public void f(double d)方法，f调用父类的g(double),g(double)被重写调用子类的g(double)
        obj1.g(3);//调用父类的g(int)
        obj1.g(4.0);//父类g(double)被重写
        C obj2=new C(5);
        obj2.f(6);//
        obj2.g(7);
        obj2.g(8.0);
    }
}
</code></pre>
<p>输出：<br>
B!	Constructor: 1<br>
g(double 2.0) in C!<br>
g(int 3) in B!<br>
g(double 4.0) in C!<br>
B!	Constructor: 5<br>
g(int 6) in B!<br>
g(int 7) in B!<br>
g(double 8.0) in C!</p>
<p>进程已结束，退出代码为 0</p>
<h1 id="分离结合的类">分离结合的类</h1>
<pre><code class="language-java">public class third {
    public static void main(String[] args) {
        Orange orange=new Orange();
        Apple apple=new Apple();
        Fruit fruit1=new Fruit(apple);
        Fruit fruit2=new Fruit(orange);
        fruit1.printfruit();
        fruit2.printfruit();
    }
}
class Apple{
    public void printOn(){
        System.out.println(&quot;This is an apple.&quot;);
    }
}
class Orange{
    public void writeTo(){
        System.out.println(&quot;This is an orange.&quot;);
    }
}
class Fruit{
    private Object fruit;
    public Fruit(Object o1) {
        fruit = o1;
    }


    public void printfruit() {
        if (fruit instanceof Apple) {
            ((Apple) fruit).printOn();
        } else if (fruit instanceof Orange) {
            ((Orange) fruit).writeTo();
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象——设计模式]]></title>
        <id>https://haifengchengguang.github.io/post/mian-xiang-dui-xiang-shang-ke-ju-de-li-zi/</id>
        <link href="https://haifengchengguang.github.io/post/mian-xiang-dui-xiang-shang-ke-ju-de-li-zi/">
        </link>
        <updated>2021-06-21T14:31:09.000Z</updated>
        <content type="html"><![CDATA[<p>创建型模式<br>
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<p>简单工厂、工厂方法、抽象工厂</p>
<p>单例<br>
对象的创建模式<br>
单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。<br>
这个类称为单例类。</p>
<p>结构型模式<br>
这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<p>适配器<br>
将一个类的接口转换成客户希望的另外一个接口。<br>
Adapter模式使得原本由于接口不兼容而不能一起的那些类可以一起工作。<br>
Adapter模式也叫做包装器Wrapper。</p>
<p>代理<br>
为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>BRIDGE（桥接<br>
把抽象部分和行为部分分离，使它们都能独立变化<br>
将抽象和行为划分开来<br>
各自独立<br>
但能动态的结合<br>
将抽象化与实现化进行脱藕</p>
<p>DECORATOR（装饰）<br>
动态地给一个对象添加一些额外的职责,别名也叫Wrapper<br>
Decorator必须和要包装的的对象具有相同的接口<br>
有时我们希望给某个对象而不是整个类添加一些功能。</p>
<p>行为型模式<br>
这些设计模式特别关注对象之间的通信。</p>
<p>OBSERVER（观察者）、<br>
定义对象间的一种一对多的依赖关系，<br>
当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并被自动更新。</p>
<p>STRATEGY(策略)<br>
定义一系列算法,把他们一个个封装起来,并且使他们可以相互替换。<br>
使算法可独立于使用它的客户。</p>
<p>责任链 CHAIN OF RESPONSIBILITY</p>
<blockquote>
<p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条扔了</p>
</blockquote>
<p>在责任链模式里，很多的对象由每一个对象对其下 家的引用而联接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Visual Studio 2022 预览版体验]]></title>
        <id>https://haifengchengguang.github.io/post/visual-studio-2022-yu-lan-ban-ti-yan/</id>
        <link href="https://haifengchengguang.github.io/post/visual-studio-2022-yu-lan-ban-ti-yan/">
        </link>
        <updated>2021-06-18T15:06:03.000Z</updated>
        <content type="html"><![CDATA[<p>下载地址<br>
https://visualstudio.microsoft.com/zh-hans/vs/preview/vs2022/<br>
社区版、专业版和商业版都可以免费使用<br>
我下载的是<br>
<img src="https://haifengchengguang.github.io/post-images/1624028850738.png" alt="" loading="lazy"><br>
预览版与稳定版是可以共存的<br>
<img src="https://haifengchengguang.github.io/post-images/1624285664683.png" alt="" loading="lazy"><br>
因为是64位的所以打开的速度要比之前的版本快一些<br>
<img src="https://haifengchengguang.github.io/post-images/1624285852061.png" alt="" loading="lazy"><br>
只有英文版</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[山东大学软件学院华为RDS for MySQL数据库实验]]></title>
        <id>https://haifengchengguang.github.io/post/shan-dong-da-xue-ruan-jian-xue-yuan-hua-wei-rds-for-mysql-shu-ju-ku-shi-yan/</id>
        <link href="https://haifengchengguang.github.io/post/shan-dong-da-xue-ruan-jian-xue-yuan-hua-wei-rds-for-mysql-shu-ju-ku-shi-yan/">
        </link>
        <updated>2021-06-11T07:11:43.000Z</updated>
        <content type="html"><![CDATA[<p align="right">edit at 11/6/2021</p>
<p>基于华为 RDS for MySQL 数据库 实验指导书</p>
<h1 id="第一部分实验要求">第一部分：实验要求</h1>
<h2 id="一-关于索引的思考">一、关于索引的思考</h2>
<p>请思考以下 SQL 是否需要索引以及如何建立索引以及如何建立索引。给出不建立索引、建立不同索引时 SQL 的执行时间。<br>
下列查询最慢的需要2秒，感觉这速度可以了hhh，不用建索引了</p>
<p>1、	查询学号为“200900140169”的学生选修的所有课程名称和考试成绩。</p>
<pre><code class="language-sql">select a.sid,a.cid,a.score,b.cname from `student_course` AS a,`course` AS b  WHERE a.sid='200900140169' and a.cid=b.cid
</code></pre>
<p>9ms</p>
<p>2、	查询“软件学院”学生的姓名。</p>
<pre><code class="language-sql">select dno from department where dname='软件学院'
</code></pre>
<p>10ms<br>
dno='d10'</p>
<pre><code class="language-sql">select name from student where dno='d10'
</code></pre>
<p>11ms</p>
<p>3、	查询“软件学院”的学生学号和选修课程的编号。</p>
<pre><code class="language-sql">select sid,cid from student_course where sid in SELECT sid FROM student WHERE dno='d10'
</code></pre>
<p>11ms</p>
<p>4、	查询学生姓名、所选课程和考试成绩。（仅包含选课的学生）</p>
<pre><code class="language-sql">select sid,cid,score from student_course 
</code></pre>
<p>10ms</p>
<pre><code class="language-sql">select sid,student_course.cid,cname,score from student_course,course where student_course.cid =course.cid
</code></pre>
<p>23ms</p>
<p>5、	查询学生姓名、所选课程和考试成绩。（包含所有的学生）</p>
<pre><code class="language-sql">SELECT student.sid,cid,score 
FROM student
	LEFT JOIN student_course ON student.sid = student_course.sid 
</code></pre>
<p>9ms</p>
<pre><code class="language-sql">SELECT sid,a.cid,cname,score FROM 
(SELECT student.sid as sid,cid,score 
FROM student
	LEFT JOIN student_course ON student.sid = student_course.sid) as a
,course WHERE a.cid=course.cid
</code></pre>
<p>9ms</p>
<p>6、	查询每门课(仅限于被学生选修的课程)的课程名称、平均成绩、最高成绩、 最低成绩和选修学生人数。</p>
<pre><code class="language-sql">SELECT cname, avg(score), max(score)
	, MIN(score), COUNT(sid)
FROM course, student_course
WHERE course.cid = student_course.cid
GROUP BY student_course.cid
</code></pre>
<p>1953ms 这个需要建索引</p>
<p>7、	查询每门课(包括没有学生选修的课程)的课程名称、平均成绩、最高成绩、 最低成绩和选修学生人数。</p>
<pre><code class="language-sql">SELECT cname, avg(score), max(score)
	, MIN(score), COUNT(sid)
FROM (select student.sid as sid,cid,score FROM student LEFT JOIN student_course ON student.sid=student_course.sid) as a,course 
WHERE course.cid = a.cid
GROUP BY course.cid 
</code></pre>
<p>2052 ms 需要建索引</p>
<p>8、	查询选课学生的平均学时和平均学分。</p>
<pre><code class="language-sql">SELECT AVG(sumperiod),avg(sumcredit) from (select sid,sum(period) as sumperiod,sum(credit) as sumcredit from student_course,course WHERE student_course.cid =course.cid GROUP BY sid) as a 
</code></pre>
<p>1392 ms 需要建索引</p>
<p>9、	查询全体学生的平均选课数量（包括未选课的学生）。</p>
<pre><code class="language-sql">SELECT AVG(countcid) FROM (SELECT student.sid,COUNT(cid) as countcid FROM student LEFT JOIN student_course on student.sid=student_course.sid GROUP BY sid) as a 
</code></pre>
<p>238 ms</p>
<h2 id="二-请撰写华为rds-for-mysql-数据库与oracle-数据库在-使用方面的对比体会">二、请撰写华为RDS for MySQL 数据库与Oracle 数据库在 使用方面的对比体会。</h2>
<p>1、Mysql更名运算需要加as，Oracle不能加<br>
2、mysql要求每一个派生出来的表都必须有一个自己的别名，用as给派生表加上别名即可；<br>
<img src="https://haifengchengguang.github.io/post-images/1623395594033.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[罗翔语录]]></title>
        <id>https://haifengchengguang.github.io/post/luo-xiang-yu-lu/</id>
        <link href="https://haifengchengguang.github.io/post/luo-xiang-yu-lu/">
        </link>
        <updated>2021-06-02T11:03:26.000Z</updated>
        <content type="html"><![CDATA[<p align="right">edit at 2/6/2021</p>
<h3 id="爱">爱</h3>
<blockquote>
<p>如果爱只是一种感觉。那么当爱遇到挑战，这种感觉很快就会消除。因为我们很容易在不同的人身上获得这种感觉，所以移情别恋最经常的说辞就是我没有感觉了。但真正的爱并非一种感觉，它更多的是一种责任，是一种彼此的牺牲和彼此的成就。真正的爱移动不是瞬间的感动，而必然是恒久的一种委身。彼此牺牲，彼此成就，彼此尊重。</p>
</blockquote>
<h3 id="天生犯罪人">天生犯罪人</h3>
<blockquote>
<p>我们每个人内心都有幽暗的成分，遇到合适的环境这些幽暗可能会被释放，所以我们永远要对自己的内心的幽暗保持警惕，所以在这个意义上我们似乎都是天生犯罪人，所以我们要远离那些会激发我们幽暗的环境，但无论如何我们都要为我们的选择付出代价。</p>
</blockquote>
<h3 id="克隆人">克隆人</h3>
<blockquote>
<p>毁灭人类的七种东西：<br>
没有原则的政治<br>
没有辛劳的财富<br>
没有人格的学识<br>
没有人性的科学<br>
没有道德的商业<br>
没有良知的享乐<br>
没有牺牲的敬拜<br>
——甘地<br>
没有人性的科学，科学没有道德的限制，人类终将会毁灭</p>
</blockquote>
<h3 id="吐槽大会">吐槽大会</h3>
<blockquote>
<p>很多人沉迷于寻找独立的意义和价值，渴望和人类伟大的传承相隔绝，于是幻想着进入一个黄金时代，结果却掉进了一个粪坑。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库实验]]></title>
        <id>https://haifengchengguang.github.io/post/shu-ju-ku-shi-yan/</id>
        <link href="https://haifengchengguang.github.io/post/shu-ju-ku-shi-yan/">
        </link>
        <updated>2021-05-25T10:02:24.000Z</updated>
        <content type="html"><![CDATA[<p align="right">edit at 25/5/2021</p>
<h2 id="数据库实验四">数据库实验四</h2>
<p>实验四 复制表、修改表结构、修改数据</p>
<p>一、 实验内容</p>
<p>利用 oracle 管理平台完成对表的结构、数据进行修改，每一个问题可以通过多个 SQL 语句完成。<br>
二、 实验题目<br>
1．将 pub 用户下表 student_41 及数据复制到主用户的表 test4_01 中，使用 alter table 语句为表增加列： “总成绩:sum_score”。 使用 update 语句,利用 pub.student_course，统计 “总成绩”；<br>
2．将 pub 用户下表 student_41 及数据复制到主用户的表 test4_02 中，使用 alter table 语句为表增加列 “平均成绩:avg_score” （小数点后保留 1 位）。 利用 pub.student_course，统计“平均成绩”，四舍五入到小数点后 1 位<br>
3．将 pub 用户下表 student_41 及数据复制到主用户的表 test4_03 中，使用 alter table 语句为表增加列： “总学分:sum_credit”。 使用 update 语句,利用 pub.student_course、pub.course，统计 “总学分”； 这是需要注意：成绩及格才能够计算所得学分,一门课多个成绩都及格只计一次学分。<br>
4．将 pub 用户下表 student_41 及数据复制到主用户的表 test4_04 中。 根据列院系名称 dname 到 pub.department 找到对应院系编号 did，将对应的院系编号回填到院系名称列 dname 中，如果表中没有对应的院系名称，则列 dname 中内容不变仍然是原来的内容。<br>
5．将 pub 用户下表 student_41 及数据复制到主用户的表 test4_05 中，使用 alter table 语句为表增加 4 个列：“总成绩:sum_score”、 “平均成绩:avg_score”、“总学分:sum_credit”、“院系编号:did varchar(2) ”。 （1） 利用 pub.student_course、pub.course，统计 “总成绩”； （2） 利用 pub.student_course、pub.course，统计“平均成绩”，四舍五入到小数点后 1 位； （3） 利用 pub.student_course、pub.course，统计 “总学分”； （4） 根据院系名称到 pub.department 或者 pub.department_41 中，找到对应编号，填写到院系编号 中，如果都没有对应的院系，则填写为 00。<br>
说明：执行 update 后，在查询表中数据，可能出现顺序变化，这是正常，因为数据在表中是无序。需要 顺序的时候可以通过 orderby 实现。<br>
6．将 pub 用户下的 Student_42 及数据复制到主用户的表 test4_06 中,对表中的数据进行整理，修复那些 不规范的数据： 剔除姓名列中的所有空格；<br>
第 18 页 共 34 页7．将 pub 用户下的 Student_42 及数据复制到主用户的表 test4_07 中,对表中的数据进行整理，修复那些 不规范的数据： 对性别列进行规范（需要先确定哪些性别数据不规范，也就是那些和大多数不一样的就是不规范的）；<br>
8．将 pub 用户下的 Student_42 及数据复制到主用户的表 test4_08 中,对表中的数据进行整理，修复那些 不规范的数据： 对班级列进行规范（需要先确定哪些班级不规范）。<br>
9．将 pub 用户下的 Student_42 及数据复制到主用户的表 test4_09 中,对表中的数据进行整理，修复那些 不规范的数据： 年龄为空值的根据出生日期设置学生年龄（截止到 2012 年的年龄，即年龄=2012-出生年份），年龄不 为空值的不要改变。<br>
10． 将 pub 用户下的 Student_42 及数据复制到主用户的表 test4_10 中,对表中的数据进行整理，修复那些 不规范的数据： （1） 剔除姓名列中的所有空格； （2） 剔除院系名称列中的所有空格； （3） 对性别列进行规范（需要先确定哪些性别数据不规范，也就是那些和大多数不一样的就是不规范 的）；<br>
（4） 对班级列进行规范（需要先确定哪些班级不规范）。 （5） 年龄为空值的根据出生日期设置学生年龄（截止到 2012 年的年龄，即年龄=2012-出生年份）， 年龄不为空值的不要改变。</p>
<p>4-1</p>
<pre><code class="language-sql">update test4_01 set sum_score=(select sum(score) from pub.student_course a where a.sid=test4_01.sid)
</code></pre>
<p>4-2</p>
<pre><code class="language-sql">update test4_02 set avg_score=
(select ROUND(avg(score),1) from pub.student_course a where test4_02.sid=a.sid)
</code></pre>
<p>4-3</p>
<pre><code class="language-sql">update test4_03 set sum_credit=(select sum(credit)
from ((select sid,cid,max(score) score from pub.student_course group by sid,cid) natural join pub.course) where test4_03.sid=sid and score&gt;=60)
</code></pre>
<p>4-4</p>
<pre><code class="language-sql">update test4_04 set dname= (select a.did from pub.department a where test4_04.dname=a.dname) where exists (select a.did from pub.department a where test4_04.dname=a.dname)
</code></pre>
<p>4-5</p>
<pre><code class="language-sql">create table test4_05 as select * from pub.student_41
alter table test4_05 add (sum_score int,avg_score BINARY_DOUBLE,sum_credit int,did varchar(2))
update test4_05 set sum_score=(select sum(score) from pub.student_course a where a.sid=test4_05.sid)
update test4_05 set avg_score=
(select ROUND(avg(score),1) from pub.student_course a where test4_05.sid=a.sid)
update test4_05 set sum_credit=(select sum(credit)
from ((select sid,cid,max(score) score from pub.student_course group by sid,cid) natural join pub.course) where test4_05.sid=sid and score&gt;=60)
update test4_05 set did=(select did from pub.DEPARTMENT
where pub.DEPARTMENT.DNAME=test4_05.dname)
update test4_05 set did=(select did from pub.DEPARTMENT_41 where pub.DEPARTMENT_41.DNAME=test4_05.dname)where dname in(select dname from pub.DEPARTMENT_41)
update test4_05 set did='00'where did is null
</code></pre>
<p>4-6</p>
<pre><code class="language-sql">update test4_06 set name=translate(name,'/ ','/')
</code></pre>
<p>4-7</p>
<pre><code class="language-sql">update test4_07 set sex=translate(sex,'/ ','/')
update test4_07 set sex=translate(sex,'/性','/')
</code></pre>
<p>4-8</p>
<pre><code class="language-sql">update test4_08 set class=translate(class,'/级','/')
</code></pre>
<p>4-9</p>
<pre><code class="language-sql">update 
</code></pre>
<p>5-3</p>
<pre><code class="language-sql">create table test5_03 as select dname,class,count(sid) p_count from pub.student where dname is not null group by dname,class
</code></pre>
<pre><code class="language-sql">alter table test5_03 add (p_count1 int,p_count2 int)
</code></pre>
<pre><code class="language-sql">update test5_03 t set p_count1 = 
(select count(sid)
from (
	select S.sid,S.dname,S.class
	from pub.student S,pub.course C,pub.student_course SC
	where S.sid = SC.sid and C.cid=SC.cid and SC.score &gt;= 60
	group by S.sid,S.dname,S.class
	having sum(C.credit) &gt;= 10
) temp
where t.dname = temp.dname and t.class  = temp.class)
</code></pre>
<pre><code class="language-sql">update test5_03 set p_count2=p_count-p_count1
</code></pre>
<p>5-4</p>
<pre><code class="language-sql">update test5_04 t set p_count1 =case
    when t.class&gt;2008 then
(select count(sid)
from (
	select S.sid,S.dname,S.class
	from pub.student S,pub.course C,pub.student_course SC
	where S.sid = SC.sid and C.cid=SC.cid and SC.score &gt;= 60
	group by S.sid,S.dname,S.class
	having sum(C.credit) &gt;= 10
) temp
where t.dname = temp.dname and t.class  = temp.class)
else
(select count(sid)
from (
	select S.sid,S.dname,S.class
	from pub.student S,pub.course C,pub.student_course SC
	where S.sid = SC.sid and C.cid=SC.cid and SC.score &gt;= 60
	group by S.sid,S.dname,S.class
	having sum(C.credit) &gt;= 8
) temp
where t.dname = temp
</code></pre>
<p>5-5</p>
<pre><code class="language-sql">
</code></pre>
<p>5-6</p>
<pre><code class="language-sql">create table test5_06 as select distinct sid,name,dname
from pub.student natural join pub.student_course
where sid in(
    select sid from pub.student natural join pub.student_course where cid='300002' and dname='计算机科学与技术学院'
    intersect
    select sid from pub.student natural join pub.student_course where cid='300005' and dname='计算机科学与技术学院'
    )
alter table test5_06 add (ds_score int,os_score int)
update test5_06 t set ds_score=
(
    select max(score)
    from pub.student_course
    where cid='300002' and t.sid=sid
    )
update test5_06 t set os_score=
(
    select max(score)
    from pub.student_course
    where cid='300005' and t.sid=sid
    )
</code></pre>
<p>5-7</p>
<pre><code>将intersect换成union
</code></pre>
<p>5-8</p>
<pre><code class="language-sql">create table test5_08 as select distinct sid,name,dname
from pub.student
where dname='计算机科学与技术学院'
alter table test5_08 add (ds_score int,os_score int)
update test5_08 t set ds_score=
(
    select max(score)
    from pub.student_course
    where cid='300002' and t.sid=sid
    )
update test5_08 t set os_score=
(
    select max(score)
    from pub.student_course
    where cid='300005' and t.sid=sid
    )
</code></pre>
<p>7-1</p>
<pre><code class="language-sql">create index test7_01_name on test7_01(substr(name,1,1))
</code></pre>
<p>7-2</p>
<pre><code class="language-sql">create index test7_02_namebirth on test7_02(birthday,name)
create index test7_02_namebirth on test7_02(name,birthday)//不行
</code></pre>
<p>7-3</p>
<pre><code class="language-sql">select * from
(select sid,name,birthday,
(select count(*) from pub.student
where substr(name,1,1)
) samefirstname 
from pub.student_testindex t1) where samefirstname=7
</code></pre>
<p>7-4</p>
<pre><code class="language-sql">create view test7_03 as
select * from
(select sid,name,birthday,
(select count(*) from pub.student
where name like concat(substr(t1.name,1,1),'%')
) samefirstname
from pub.student_testindex t1) where samefirstname=7
</code></pre>
<p>7-5</p>
<p>一、截取时间</p>
<pre><code class="language-sql">select  trunc(to_date('2018-02-01 1:00:00','YYYY-MM-DD HH:MI:SS'),'yyyy') from   dual ;--返回当年第一天
select  trunc(to_date('2018-02-01 1:00:00','YYYY-MM-DD HH:MI:SS'),'mm') from   dual ; --返回当月第一天
select  trunc(to_date('2018-02-01 1:00:00','YYYY-MM-DD HH:MI:SS'),'dd') from   dual ;--返回当前年月
select  trunc(to_date('2018-02-01 1:00:00','YYYY-MM-DD HH:MI:SS'),'d') from   dual ; --返回当前星期的第一天(星期日) 
select  trunc(to_date('2018-02-01 1:12:12','YYYY-MM-DD HH:MI:SS'),'hh') from   dual ;--返回当前日期截取到小时,分秒补0
select  trunc(to_date('2018-02-01 1:12:12','YYYY-MM-DD HH:MI:SS'),'mi') from   dual ;--返回当前日期截取到分,秒补0
</code></pre>
<p>————————————————</p>
<p>比较同年同月的时候，应当为birthday&gt;=本月第一天且birthday&lt;=本月最后一天，这里本月是指t1.birthday所在月；比较同年的时候，应当为birthday&gt;=本年第一天且birthday&lt;=本年最后一天，这里本月是指t1.birthday所在年。<br>
函数trunc(date,fmt)可以用来截取日期，例如trunc (t1.birthday,‘mm’)结果即为t1.birthday所在月的第一天的00:00:00，而trunc(t1.birthday,‘yyyy’)则获得当年1月1日00:00:00。<br>
函数last_day(date)可以获得该日期所在月的最后一天。<br>
函数add_months(date,plusMonth)可以实现月份相加，即返回结果为日期date加上plusMonth个月之后的日期。<br>
于是本年最后一天可以表示为last_day(add_months(trunc(t1.birthday,‘yyyy’),11))<br>
修改语句为：</p>
<pre><code class="language-sql">
</code></pre>
<p>查看系统时间</p>
<pre><code class="language-sql">select to_char(sysdate,'yyyy-MM-dd HH24:mi:ss') from dual;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象设计原则]]></title>
        <id>https://haifengchengguang.github.io/post/mian-xiang-dui-xiang-she-ji-yuan-ze/</id>
        <link href="https://haifengchengguang.github.io/post/mian-xiang-dui-xiang-she-ji-yuan-ze/">
        </link>
        <updated>2021-05-25T10:00:13.000Z</updated>
        <content type="html"><![CDATA[<p align="right">edit at 22/6/2021</p>
<figure data-type="image" tabindex="1"><img src="https://haifengchengguang.github.io/post-images/1624342406341.png" alt="" loading="lazy"></figure>
<h3 id="single-responsibility-principlesrp单一职责原则">Single Responsibility Principle，SRP：单一职责原则</h3>
<p>单一职责原则简称 SRP ，顾名思义，就是一个类只负责一个职责。那这个原则有什么用呢，它让类的职责更单一。</p>
<h3 id="open-closed-principleocp开闭原则">Open Closed Principle，OCP：开闭原则</h3>
<p>一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭</p>
<h3 id="liskov-substitution-principlelsp里氏替换原则">Liskov Substitution Principle，LSP：里氏替换原则</h3>
<p>如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。</p>
<p>换言之，一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。</p>
<p>比如，假设有两个类，一个是Base类，另一个是Child类，并且Child类是Base的子类。那么一个方法如果可以接受一个基类对象b的话:method1(Base b)那么它必然可以接受一个子类的对象method1(Child c).</p>
<p>里氏替换原则是继承复用的基石。只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才能真正的被复用，而衍生类也才能够在基类的基础上增加新的行为。</p>
<p>但是需要注意的是，反过来的代换是不能成立的，如果一个软件实体使用的是一个子类的话，那么它不一定适用于基类。如果一个方法method2接受子类对象为参数的话method2(Child c)，那么一般而言不可以有method2(b).</p>
<h3 id="law-of-demeterlod迪米特法则">Law of Demeter，LoD：迪米特法则</h3>
<p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<h3 id="interface-segregation-principleisp接口隔离原则">Interface Segregation Principle，ISP：接口隔离原则</h3>
<p>继承多个接口，使用多个专一的接口代替一个统一的接口。</p>
<h3 id="dependence-inversion-principledip依赖倒置原则">Dependence Inversion Principle，DIP：依赖倒置原则</h3>
<p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。</p>
<h3 id="composite-reuse-principlecrp合成复用原则">Composite Reuse Principle，CRP：合成复用原则</h3>
<p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用这些对象的目的。</p>
<p>如果两个类是“Has-a”关系应使用合成、聚合，如果是“Is-a”关系可使用继承。&quot;Is-A&quot;是严格的分类学意义上定义，意思是一个类是另一个类的&quot;一种&quot;。而&quot;Has-A&quot;则不同，它表示某一个角色具有某一项责任。</p>
<p>什么是合成?什么是聚合</p>
<p>合成（Composition）和聚合（Aggregation）都是关联（Association）的特殊种类。</p>
<p>聚合</p>
<p>聚合用来表示“拥有”关系或者整体与部分的关系。代表部分的对象有可能会被多个代表整体的对象所共享，而且不一定会随着某个代表整体的对象被销毁或破坏而被销毁或破坏，部分的生命周期可以超越整体。例如，班级和学生，当班级删除后，学生还能存在，学生可以被培训机构引用。在设计中, 聚合不应该频繁出现，这样会增大设计的耦合度。</p>
<p>聚合关系UML类图</p>
<pre><code class="language-javascript">class Student {

}

class Classes{

         private Student student;

         publicClasses(Student student){

                   this.student=student;
        }

}
</code></pre>
<p>合成</p>
<p>合成用来表示一种强得多的“拥有”关系。在一个合成关系里，部分和整体的生命周期是一样的。一个合成的新对象完全拥有对其组成部分的支配权，包括它们的创建和湮灭等。使用程序语言的术语来说，合成而成的新对象对组成部分的内存分配、内存释放有绝对的责任。一个合成关系的成分对象是不能与另一个合成关系共享的。</p>
<p>合成关系UML类图</p>
<pre><code class="language-javascript">class Room{

         public Room createRoom(){
                   System.out.println(“创建房间”);
                   returnnew Room();
          } 
 }

class House{

         private Room room;

         public House(){ 
               room=new Room();
          }

         public void createHouse(){
                room.createRoom();
         } 
  }
</code></pre>
<p>换句话说，合成是值的聚合（Aggregation by Value），而一般说的聚合是引用的聚合（Aggregation by Reference）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ pta]]></title>
        <id>https://haifengchengguang.github.io/post/c-pta/</id>
        <link href="https://haifengchengguang.github.io/post/c-pta/">
        </link>
        <updated>2021-05-18T06:10:45.000Z</updated>
        <content type="html"><![CDATA[<p align="right">edit at 25/5/2021</p>
<p>6-1 类模板Point的定义与使用 (10 分)<br>
定义类模板Point，有两个坐标(x,y)，x和y的类型可以不同，坐标的数据类型可以是int、float,double类型. 具有获取坐标的成员函数getX和getY。</p>
<p>接口定义：</p>
<p><code>class Point</code><br>
裁判测试程序</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

@@@

int main()
{

    Point&lt;int, int&gt; p1(10, 20);
    Point&lt;int, float&gt; p2(10, 20.5f);
    Point&lt;float, float&gt; p3(10.5f, 20.5f);
    Point&lt;double, double &gt; p4(10.5, 20.5);
    cout&lt;&lt;p1.getX()&lt;&lt;&quot;,&quot;&lt;&lt;p1.getY()&lt;&lt;endl;
    cout&lt;&lt;p2.getX()&lt;&lt;&quot;,&quot;&lt;&lt;p2.getY()&lt;&lt;endl;
    cout&lt;&lt;p3.getX()&lt;&lt;&quot;,&quot;&lt;&lt;p3.getY()&lt;&lt;endl;
    cout&lt;&lt;p4.getX()&lt;&lt;&quot;,&quot;&lt;&lt;p4.getY()&lt;&lt;endl;
  return 0;

}

/* 请在这里填写答案 */
</code></pre>
<p>10,20<br>
10,20.5<br>
10.5,20.5<br>
10.5,20.5</p>
<pre><code class="language-c++">template&lt;class T,class U&gt;
class Point
{
public:
	T x;
	U y;
	Point(T x,U y)
	{
		this-&gt;x = x;
		this-&gt;y = y;
	}
	T getX() const;
	U getY() const;
	
};
template &lt;class T, class U&gt;
T Point&lt;T, U&gt;::getX() const
{
	return x;
}
template &lt;class T, class U&gt;
U Point&lt;T, U&gt;::getY() const
{
	return y;
}
</code></pre>
<p>7-1 设计一个矩形类Rectangle并创建测试程序（C++） (10 分)<br>
设计一个名为Rectangle的矩形类，这个类包括：两个名为width和height的double数据域，它们分别表示矩形的宽和高。width和height的默认值都为1.该类包括矩形类的无参构造函数（默认构造函数）；一个width和height为指定值的矩形构造函数；一个名为getArea( )的函数返回矩形的面积；一个名为getPerimeter( )的函数返回矩形的周长。请实现这个类。编写一个测试程序，创建一个Rectangle对象，从键盘输入矩形的宽和高，然后输出矩形的面积和周长。</p>
<p>输入格式:<br>
3.5 35.9（第一个数表示矩形的宽，第二个数表示矩形的高，中间是空间分隔。）</p>
<p>输出格式:<br>
125.65 （第一行输出矩形的面积） 78.8 （第二行输出矩形的周长）</p>
<p>输入样例:<br>
3.5 35.9<br>
输出样例:<br>
125.65<br>
78.8</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class Rectangle
{
public:
	double width;
	double height;
	Rectangle()
	{
		width = 1.0;
		height = 1.0;
	}
	Rectangle(double width,double height)
	{
		this-&gt;height = height;
		this-&gt;width = width;
	}
	double getArea();
	double getPerimeter();
	
};
double Rectangle::getArea()
{
	return height * width;
}
double Rectangle::getPerimeter()
{
	return height * 2.0 + width * 2.0;
}

int main()
{
	double height, width;
	cin &gt;&gt; height &gt;&gt; width;
	Rectangle rectangle(width,height);
	cout &lt;&lt; rectangle.getArea() &lt;&lt; endl;
	cout &lt;&lt; rectangle.getPerimeter() &lt;&lt; endl;
	
	
	
}
</code></pre>
<p>7-2 复数类的运算 (10 分)<br>
根据以下代码段完善 ?? 处内容及程序内容，以实现规定的输出。</p>
<p>class Complex<br>
{<br>
public:<br>
Complex(double r=0, double i=0):real(r), imag(i){    }<br>
Complex operator+( ?? ) const;//重载双目运算符'+'<br>
Complex operator-=( ?? ); //重载双目运算符'-='<br>
friend Complex operator-( ?? ) const;//重载双目运算符'-'<br>
void Display() const;<br>
private:<br>
double real;<br>
double imag;<br>
};</p>
<p>void Complex::Display() const<br>
{<br>
cout &lt;&lt; &quot;(&quot; &lt;&lt; real &lt;&lt; &quot;, &quot; &lt;&lt; imag &lt;&lt; &quot;)&quot; &lt;&lt; endl;<br>
}</p>
<p>int main()<br>
{<br>
double r, m;<br>
cin &gt;&gt; r &gt;&gt; m;<br>
Complex c1(r, m);<br>
cin &gt;&gt; r &gt;&gt; m;<br>
Complex c2(r, m);<br>
Complex c3 = c1+c2;<br>
c3.Display();<br>
c3 = c1-c2;<br>
c3.Display();<br>
c3 -= c1;<br>
c3.Display();<br>
return 0;<br>
}<br>
输入格式:<br>
输入有两行，分别为两个复数的实部与虚部。</p>
<p>输出格式:<br>
按样例格式输出结果。</p>
<p>输入样例:<br>
在这里给出一组输入。例如：</p>
<p>4 2<br>
3 -5<br>
输出样例:<br>
在这里给出相应的输出。例如：</p>
<p>(7, -3)<br>
(1, 7)<br>
(-3, 5)</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class Complex
{
public:
    Complex(double r = 0, double i = 0) :real(r), imag(i) {    }
    Complex operator+(const Complex&amp; c) const;//重载双目运算符'+' 括号内取地址，不能修改；最后一个const表示不修改类
    Complex operator-=(const Complex&amp; c); //重载双目运算符'-='
    friend Complex operator-( const Complex&amp; b,const Complex&amp; c ) ;//重载双目运算符'-'
    void Display() const;
private:
    double real;
    double imag;
};

void Complex::Display() const
{
    cout &lt;&lt; &quot;(&quot; &lt;&lt; real &lt;&lt; &quot;, &quot; &lt;&lt; imag &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}
Complex Complex::operator+(const Complex&amp; c)const
{
    return  Complex(real + c.real, imag + c.imag);
}
Complex Complex::operator-=(const Complex&amp; c) 
{
    return Complex(real -= c.real, imag -= c.imag);
}
Complex operator-(const Complex&amp; b,const Complex&amp; c)
{
    return Complex(b.real-c.real,b.imag-c.imag);
}
int main()
{
    double r, m;
    cin &gt;&gt; r &gt;&gt; m;
    Complex c1(r, m);
    cin &gt;&gt; r &gt;&gt; m;
    Complex c2(r, m);
    Complex c3 = c1+c2;
    c3.Display();
    c3 = c1-c2;
    c3.Display();
    c3 -= c1;
    c3.Display();
    return 0;
}
</code></pre>
<p>7-3 复数的比较 (10 分)<br>
题目描述：建立一个复数类，实数和虚数是其私有数据成员。建立一个&gt;（大于号）的运算符重载，比较两个复数间模的大小。</p>
<p>输入格式：测试输入包含若干测试用例，每个测试用例占一行。每个测试用例包括四个数字，前两个数字分别表示第一个复数的实部和虚部，第三个和第四个数字分别表示第二个复数的实部和虚部。每个数字之间用空格间隔。当读入一个测试用例是0 0 0 0时输入结束，相应的结果不要输出。</p>
<p>输出格式：对每个测试用例输出一行。当第一个复数的模大于第二个复数的模时，输出 true ，当第一个复数的模小于或等于第二个复数的模时，输出false</p>
<p>输入样例：</p>
<p>3 5 4 0</p>
<p>0 3 4 1</p>
<p>0 0 0 0</p>
<p>输出样例：</p>
<p>true</p>
<p>false</p>
<pre><code class="language-c++">// negativeNumberCompare.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。
//

#include &lt;iostream&gt;
using namespace std;

class negativeNumber
{
public:
	friend bool operator&gt;(const negativeNumber&amp; b, const negativeNumber&amp; c);
	negativeNumber(double r = 0, double i = 0) : real(r),imag(i){}
	//bool operator&gt;(const negativeNumber&amp; b) const;
private:
	double real;
	double imag;

};
//bool negativeNumber::operator&gt;(const negativeNumber&amp; b) const
//{
//	return (real * real + imag * imag) &gt; (b.real * b.real + b.imag * b.imag);
//}
bool operator&gt;(const negativeNumber&amp; b, const negativeNumber&amp; c)
{
	return  (b.real * b.real + b.imag * b.imag)&gt; (c.real * c.real + c.imag * c.imag);
}
int main()
{
	/*negativeNumber b(1, 1);
	negativeNumber c(2, 2);
	if (b &gt; c)
	{
		cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;
	}
	else cout &lt;&lt; &quot;correct&quot; &lt;&lt; endl;*/
	while (true)
	{
		int a, b, c, d;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
		if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0 &amp;&amp; d == 0) break;
		negativeNumber x(a, b);
		negativeNumber y(c, d);
		if (x &gt; y) cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;
		else cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;
	}
	
	
}

</code></pre>
<p>7-7 车辆选择（继承） (10 分)<br>
有一个汽车类vehicle，它具有一个需传递参数的构造函数，汽车类vehicle中的数据成员为： 车轮个数wheels和车重weight放在保护段中，汽车类vehicle中的公有成员函数为：get_wheels()（返回车轮个数的值）、get_weight()（返回车重的值）、wheel_load()（返回每个轮胎的载重量的值：weight/wheels）、print()（输出车轮的个数和车重的公斤数）；</p>
<p>小车类car是vehicle类的派生类，它具有一个需传递参数的构造函数，小车类car中的私有数据成员为：车载人数passenger_load，小车类car中的公有成员函数为：get_passengers()（返回车载人数的值）、print()（输出小车车轮的个数和车重的公斤数以及车载人数的个数）；</p>
<p>卡车类truck是vehicle类的派生类，它具有一个需传递参数的构造函数，卡车类truck中的私有数据成员为：载人数passenger_load和载重量payload，卡车类truck中的公有成员函数为：get_passengers()（返回车载人数的值）、efficiency（）(返回卡车的载重效率的值：payload/(payload+weight)、print()（输出卡车车轮的个数和车重的公斤数以及车载人数的个数和卡车的载重效率的值）)。</p>
<p>生成上述类并编写主函数，根据输入的车辆基本信息，建立车辆对象，并能计算输出该车辆的基本信息。 输入格式：测试输入包含一个测试用例，每一行给出一个车辆的基本信息，每行的第一个字符处为当前车辆的类型，第二个数字为当前车辆的编号，若车辆为vehicle，后面跟随两个数字分别为wheels和weight，若车辆为car，后面跟随三个数字分别为wheels，weight和车载人数，若车辆为truck，后面跟随四个数字分别是wheels，weight、车载人数和载重量。（以上数字均为整型）。-1表示输入结束，相应结果不要输出。请注意输出格式，按照输入顺序进行编号 说明：本题中轮胎载重量、载重效率若需输出保留小数点后两位。</p>
<p>输入样例：</p>
<p>vehicle 101 4 1900</p>
<p>car 201 4 2000 5</p>
<p>truck 301 6 3000 2 9000</p>
<p>car 202 4 1800 4</p>
<p>-1</p>
<p>输出样例：</p>
<p>The 1st object is Vehicle No. 101: weight 1900 Kg and wheels 4</p>
<p>The 2nd object is Car No. 201: passenger_load 5 weight 2000 Kg and wheels 4</p>
<p>The 3rd object is Truck No. 301: passenger_load 2 weight 3000 Kg wheels 6 and efficiency 0.75</p>
<p>The 4th object is Car No. 202: passenger_load 4 weight 1800 Kg and wheels 4</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class vehicle
{
public:
	vehicle(int whee,int weig):wheels(whee),weight(weig){}
	int get_wheels() { return wheels; }
	int get_weight() { return weight; }
	int wheel_load() { return weight / wheels; }
	virtual void print() { printf(&quot;weight %d Kg and wheels %d&quot;, weight, wheels); }
protected:
	int wheels;
	int weight;
};

class car:vehicle
{
public:
	car(int pass,int whee,int weig):vehicle(whee,weig)
	{
		passenger_load = pass;
	}
	int get_passengers() { return passenger_load; }
	void print() { printf(&quot;passenger_load %d weight %d Kg and wheels %d&quot;, passenger_load, weight, wheels); }
private:
	int passenger_load;
};

class truck:vehicle
{
public:
	truck(int pay,int pass, int whee, int weig):vehicle(whee,weig)
	{
		passenger_load = pass;
		payload = pay;
	}
	int get_passengers() { return passenger_load; }
	double efficiency() {
		return (double) payload / (payload + weight);
	}
	void print() { printf(&quot;passenger_load %d weight %d Kg wheels %d and efficiency %0.2f&quot;, passenger_load, weight, wheels, efficiency()); }
private:
	int passenger_load;
	int payload;
};
const char* ordinal_suffix(int n)
{
	static const char suffixes[][3] = { &quot;th&quot;, &quot;st&quot;, &quot;nd&quot;, &quot;rd&quot; };
	auto ord = n % 100;
	if (ord / 10 == 1) { ord = 0; }
	ord = ord % 10;
	if (ord &gt; 3) { ord = 0; }
	return suffixes[ord];
}
int main()
{
	int count1 = 0;
	while (true)
	{
		count1++;
		string a;
		cin &gt;&gt; a;
		int number, whel, weg;
		if (a == &quot;vehicle&quot;)
		{
			cin &gt;&gt; number &gt;&gt; whel &gt;&gt; weg;
			vehicle vehicle1(whel, weg);
			//printf(&quot;The %dst object is %s No. %d: &quot;,count1,a,b);
			cout &lt;&lt; &quot;The &quot; &lt;&lt; count1 &lt;&lt;ordinal_suffix(count1)&lt;&lt; &quot; object is Vehicle No. &quot; &lt;&lt; number &lt;&lt; &quot;: &quot;;
			vehicle1.print();
			cout &lt;&lt; endl;
			
		}
		else if (a == &quot;car&quot;)
		{
			int passager;
			cin &gt;&gt; number &gt;&gt; whel &gt;&gt; weg &gt;&gt; passager;
			car car1(passager, whel, weg);
			//printf(&quot;The %dst object is Vehicle No. %d: &quot;, count1, b);
			cout &lt;&lt; &quot;The &quot; &lt;&lt; count1 &lt;&lt; ordinal_suffix(count1) &lt;&lt; &quot; object is Car No. &quot; &lt;&lt; number &lt;&lt; &quot;: &quot;;
			car1.print();
			cout &lt;&lt; endl;
			
		}
		else if (a == &quot;truck&quot;)
		{
			int passager, payee;
			cin &gt;&gt; number &gt;&gt; whel &gt;&gt; weg &gt;&gt; passager &gt;&gt; payee;
			truck truck1(payee, passager, whel, weg);
			cout &lt;&lt; &quot;The &quot; &lt;&lt; count1 &lt;&lt; ordinal_suffix(count1) &lt;&lt; &quot; object is Truck No. &quot; &lt;&lt; number &lt;&lt; &quot;: &quot;;
			truck1.print();
			cout &lt;&lt; endl;
			
		}
		else if (a == &quot;-1&quot;)
		{
			exit(0);
		}
	}
}
</code></pre>
<p>7-8 多边形周长计算（继承） (10 分)<br>
给出下面的多边形基类框架：</p>
<p>class polygon</p>
<p>{ protected:</p>
<p>int number;//边数，最多不超过100条边<br>
private:</p>
<p>int side_length[100];//边长数组<br>
public:</p>
<p>polygon();//构造函数根据需要重载<br>
int perimeter();//计算多边形边长<br>
void display();//输出多边形边数和周长<br>
}</p>
<p>建立一个派生类rectangle(矩形)，增加以下数据成员：</p>
<p>int height;<br>
int width;<br>
增加以下成员函数：</p>
<p>rectangle类的无参和参数化构造函数<br>
int perimeter();//计算矩形边长<br>
void display();//输出多边形边数和周长<br>
建立一个派生类equal_polygon(等边多边形)，增加以下数据成员：</p>
<p>int side_len;<br>
增加以下成员函数：</p>
<p>equal_polygon类的无参和参数化构造函数<br>
int perimeter();//计算等边多边形边长<br>
void display();//输出多边形边数和周长<br>
生成上述类并编写主函数，根据输入的多边形信息，相应建立一个多边形类对象或矩形类对象或等边多边形类对象，计算每一个多边形的周长并且输出其边数和周长。</p>
<p>输入格式： 测试输入包含一个测试用例，该测试用例的第一行输入多边形的个数n，接下来n行每一行给出一个多边形的基本信息，每行的第一个数字为当前多边形的类型，0为一般多边形，后面跟随m个数字为m条边的边长，-1为一般多边形边长输入结束标志，1为矩形，后面跟随两个数字，分别为height和width，2为等边多边形，后面跟随两个数字为等边多边形的边数和边长。</p>
<p>输入样例：</p>
<p>3</p>
<p>0 32 54 76 88 24 -1</p>
<p>1 32 54</p>
<p>2 3 32</p>
<p>输出样例：</p>
<p>5 274</p>
<p>4 172</p>
<p>3 96</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class polygon

{
protected:

	int number;//边数，最多不超过100条边
private:

	int side_length[100];//边长数组
public:
	polygon() { }
	polygon(int num) :number(num) {}//构造函数根据需要重载
	void setside(int i,int element)
	{
		side_length[i] = element;
	}
	virtual int perimeter()
	{
		int perime = 0;
		for(int i=0;i&lt;number;i++)
		{
			perime += side_length[i];
		}
		return perime;
	}//计算多边形边长
	virtual void display()
	{
		cout &lt;&lt; number &lt;&lt; &quot; &quot; &lt;&lt; perimeter() &lt;&lt; endl;
	}//输出多边形边数和周长
};

class rectangle:polygon
{
public:
	rectangle() {}//类的无参和参数化构造函数
	rectangle(int hei,int wid):height(hei),width(wid){}
	int perimeter() { return 2 * height + 2 * width; }//计算矩形边长
	void display() { cout &lt;&lt; &quot;4&quot; &lt;&lt; &quot; &quot; &lt;&lt; perimeter() &lt;&lt; endl; }//输出多边形边数和周长
private:
	int height;
	int width;
};

class equal_polygon:polygon
{
public:
	equal_polygon(){}
	equal_polygon(int num, int side) :polygon(num) { side_len = side; }
	int perimeter() { return number * side_len; }//计算等边多边形边长
	void display() { cout &lt;&lt; number &lt;&lt; &quot; &quot; &lt;&lt; perimeter() &lt;&lt; endl; }//输出多边形边数和周长
private:
	int side_len;
};
int main()
{
	int n;
	cin &gt;&gt; n;
	for(int i=0;i&lt;n;i++)
	{
		int kind;
		cin &gt;&gt; kind;
		if(kind==0)
		{
			vector&lt;int&gt; v;
			while (true)
			{
				int j;
				cin &gt;&gt; j;
				if(j!=-1)
				v.push_back(j);
				else break;
				
			}
			polygon polygon1(v.size());
			for (int k = 0; k &lt; v.size(); k++)
				polygon1.setside(k, v.at(k));
			polygon1.display();
		}
		else if(kind==1)
		{
			int a, b;
			cin &gt;&gt; a &gt;&gt; b;
			rectangle rectangle1(a, b);
			rectangle1.display();
		}
		else if(kind==2)
		{
			int num1, lenth;
			cin &gt;&gt; num1 &gt;&gt; lenth;
			equal_polygon equal_polygon1(num1, lenth);
			equal_polygon1.display();
		}
	}
}
</code></pre>
<p>7-9 日程安排（多重继承+重载） (10 分)<br>
已有一个日期类Date，包括三个protected成员数据</p>
<p>int year;</p>
<p>int month;</p>
<p>int day;</p>
<p>另有一个时间类Time，包括三个protected成员数据</p>
<p>int hour;</p>
<p>int minute;</p>
<p>int second;</p>
<p>现需根据输入的日程的日期时间，安排前后顺序，为此以Date类和Time类为基类，建立一个日程类Schedule，包括以下新增成员：</p>
<p>int ID；//日程的ID</p>
<p>bool operator &lt; (const Schedule &amp; s2);//判断当前日程时间是否早于s2</p>
<p>生成以上类，并编写主函数，根据输入的各项日程信息，建立日程对象，找出需要最早安排的日程，并输出该日程对象的信息。</p>
<p>输入格式： 测试输入包含若干日程，每个日程占一行（日程编号ID 日程日期（<strong>//）日程时间（:</strong>😗*））。当读入0时输入结束，相应的结果不要输出。</p>
<p>输入样例：</p>
<p>1 2014/06/27 08:00:01</p>
<p>2 2014/06/28 08:00:01</p>
<p>0</p>
<p>输出样例：</p>
<p>The urgent schedule is No.1: 2014/6/27 8:0:1</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class Date
{
public:
	int toIntData() {
		return year * 10000 + month * 100 + day;
	}
	void showdate() { cout &lt;&lt; &quot; &quot; &lt;&lt; year &lt;&lt; &quot;/&quot; &lt;&lt; month &lt;&lt; &quot;/&quot; &lt;&lt; day; }
	Date(int year1,int month1,int day1):year(year1),month(month1),day(day1){}
protected:int year;

	   int month;

	   int day;
};

class Time
{
public:
	Time(int hour1,int minute1,int second1):hour(hour1),minute(minute1),second(second1){}
	int toIntTime() {
		return hour * 10000 + minute * 100 + second;
	}
	void showtime() { cout &lt;&lt; &quot; &quot; &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second; }
protected:
	int hour;

	int minute;

	int second;
};

class Schedule:Date,Time
{
public:
	Schedule(int yea1, int mont1, int da1, int hou1, int min1, int sec1, int id1) :Date(yea1, mont1, da1), Time(hou1, min1, sec1) { ID = id1; }
	bool operator &lt; ( Schedule&amp; s2);//判断当前日程时间是否早于s
	void show() {
		cout &lt;&lt; &quot;No.&quot; &lt;&lt; ID &lt;&lt; &quot;:&quot;;
		Date::showdate();
		Time::showtime();
	}
private:
	int ID;//日程的ID
};
bool Schedule::operator&lt;(Schedule&amp; s2)
{
	if (this-&gt;toIntData() != s2.toIntData()) {
		return toIntData() &lt; s2.toIntData();
	}
	else {
		return toIntTime() &lt; s2.toIntTime();
	}
	
}

int main()
{
	int n;
	int a, b, c, d, e, f;
	Schedule s2(9999, 9999, 9999, 9999, 999, 999, 0);
	while (cin &gt;&gt; n, n != 0) {
		scanf(&quot;%d/%d/%d&quot;, &amp;a, &amp;b, &amp;c);
		scanf(&quot;%d:%d:%d&quot;, &amp;d, &amp;e, &amp;f);
		Schedule s1(a, b, c, d, e, f,n);
		if (s1 &lt; s2) {
			s2 = s1;
		}
	}
	cout &lt;&lt; &quot;The urgent schedule is &quot;; s2.show();
}
</code></pre>
<p>7-11 动物世界 (10 分)<br>
补充程序 ：</p>
<p>1、实现Mammal类的方法</p>
<p>2、由Mammal类派生出Dog类，在Dog类中增加itsColor成员(COLOR类型)</p>
<p>3、Dog类中增加以下方法：</p>
<p>constructors: Dog()、Dog(int age)、Dog(int age, int weight)、Dog(int age, COLOR color)、 Dog(int age, int weight, COLOR color)、~Dog()</p>
<p>accessors: GetColor()、SetColor()</p>
<p>Other methods: WagTail()、BegForFood() ，并实现以上这些方法 。</p>
<p>提示：类似Speak()、WagTail()这些动作，函数体可以是输出一句话。比如：Mammal is spaeking... , The Dog is Wagging its tail...</p>
<p>4、补充主函数的问号部分，并运行程序，检查输出是否合理。</p>
<p>enum COLOR{ WHITE, RED, BROWN, BLACK, KHAKI };</p>
<p>class Mammal<br>
{<br>
public:<br>
//constructors<br>
Mammal();<br>
Mammal(int age);<br>
~Mammal();</p>
<pre><code>    //accessors
    int GetAge() const;
    void SetAge(int);
    int GetWeight() const;
    void SetWeight(int);

    //Other methods    
    void Speak() const;
    void Sleep() const;        
protected:
    int itsAge;
    int itsWeight;
</code></pre>
<p>};</p>
<p>int main()<br>
{<br>
Dog Fido;<br>
Dog Rover(5);<br>
Dog Buster(6, 8);<br>
Dog Yorkie(3, RED);<br>
Dog Dobbie(4, 20, KHAKI);<br>
Fido.Speak();<br>
Rover.WagTail();<br>
cout &lt;&lt; &quot;Yorkie is &quot; &lt;&lt; ?? &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;<br>
cout &lt;&lt; &quot;Dobbie    weighs &quot; &lt;&lt; ?? &lt;&lt; &quot; pounds.&quot; &lt;&lt; endl;<br>
return 0;<br>
}<br>
输入格式:<br>
无</p>
<p>输出格式:<br>
按照程序格式输出。</p>
<p>输入样例:<br>
在这里给出一组输入。例如：</p>
<p>无<br>
输出样例:<br>
在这里给出相应的输出。例如：</p>
<p>Mammal is speaking...<br>
The dog is wagging its tail...<br>
Yorkie is 3 years old.<br>
Dobbie weighs 20 pounds.</p>
<pre><code class="language-c++">enum COLOR{ WHITE, RED, BROWN, BLACK, KHAKI };
#include&lt;iostream&gt;
using namespace std;
class Mammal
{
	public:
		//constructors
		Mammal()
		{
			itsAge=0;
			itsWeight=0;
		}
		;
		Mammal(int age)
		{
			itsAge=age;
		}
		Mammal(int age,int weight)
		{
			itsAge=age;
			itsWeight=weight;
		}
		
		//accessors
		int GetAge()const
		{
			return itsAge;
		}
	int GetWeight()const
	{
		return itsWeight;
	}
		void SetWeight(int Weight)
		{
			itsWeight=Weight;
		}
		
		//Other methods		
	protected:
		int itsAge;
		int itsWeight;
};
class Dog:public Mammal
{
	COLOR itsColor;
	public:
		void Speak(){
		cout&lt;&lt;&quot;Mammal is speaking...&quot;&lt;&lt;endl;
}
     void WagTail(){
     	cout&lt;&lt;&quot;The dog is wagging its tail...&quot;&lt;&lt;endl;
	 }
	 Dog(){
	 }
	 Dog(int age):Mammal(age)
	 {
	 	
	 }
	 Dog(int age,int weight):Mammal(age,weight)
	 {
	 	
	 }
	 Dog(int age,int weight,COLOR x):Mammal(age,weight)
	 {
	 	itsColor=x;
	 }
	 
};

int main()
{
	Dog Fido;
	Dog Rover(5);
	Dog Buster(6, 8);
	Dog Yorkie(3, RED);
	Dog Dobbie(4, 20, KHAKI);
	Fido.Speak();
	Rover.WagTail();
	cout &lt;&lt; &quot;Yorkie is &quot; &lt;&lt; Yorkie.GetAge() &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;Dobbie weighs &quot; &lt;&lt; Dobbie.GetWeight() &lt;&lt; &quot; pounds.&quot;;   
	return 0;
}
</code></pre>
<p>7-12 马会飞 (10 分)<br>
已知Horse类是Pegasus类的父类，根据以下主函数完善程序内容，以实现规定的输出。不允许改变主函数的内容。</p>
<p>int main()<br>
{<br>
Horse *p1 = new Horse; //输出：Horse 申请了空间...<br>
Horse <em>p2 = new Pegasus; /</em>  输出两行：<br>
Horse 申请了空间...<br>
Pegasus 申请了空间...<br>
*/<br>
cout &lt;&lt; endl;</p>
<pre><code>p1-&gt;Fly(); //输出：Just a horse.
p2-&gt;Fly(); //输出：I can fly!
cout &lt;&lt; endl; 

delete p1; //输出：Horse 释放了空间...
delete p2;  /* 输出两行：
               Pegasus 释放了空间... 
               Horse 释放了空间... 
        */
return 0;
</code></pre>
<p>}<br>
输入格式:<br>
无</p>
<p>输出格式:<br>
根据样例格式输出。</p>
<p>输入样例:<br>
在这里给出一组输入。例如：</p>
<p>无<br>
输出样例:<br>
在这里给出相应的输出。例如：</p>
<p>Horse 申请了空间...<br>
Horse 申请了空间...<br>
Pegasus 申请了空间...</p>
<p>Just a horse.<br>
I can fly!</p>
<p>Horse 释放了空间...<br>
Pegasus 释放了空间...<br>
Horse 释放了空间...</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class Horse
{
public:
	Horse()
	{
        cout &lt;&lt; &quot;Horse 申请了空间...&quot; &lt;&lt; endl;
	}
	virtual void Fly()
	{
        cout &lt;&lt; &quot;Just a horse.&quot; &lt;&lt; endl;
	}
	virtual ~Horse()
	{
        cout &lt;&lt; &quot;Horse 释放了空间...&quot; &lt;&lt; endl;
	}
};

class Pegasus:public Horse
{
public:
	Pegasus()
	{
        cout &lt;&lt; &quot;Pegasus 申请了空间...&quot; &lt;&lt; endl;
	}
	void Fly() override;
	~Pegasus()
	{
        cout &lt;&lt; &quot;Pegasus 释放了空间...&quot; &lt;&lt; endl;
	}
};
void Pegasus::Fly()
{
    cout &lt;&lt; &quot;I can fly!&quot; &lt;&lt; endl;
}

int main()
{
    Horse* p1 = new Horse; //输出：Horse 申请了空间...
    Horse* p2 = new Pegasus; /*  输出两行：
                                 Horse 申请了空间...
                                 Pegasus 申请了空间...
                     */
    cout &lt;&lt; endl;

    p1-&gt;Fly(); //输出：Just a horse.
    p2-&gt;Fly(); //输出：I can fly!
    cout &lt;&lt; endl;

    delete p1; //输出：Horse 释放了空间...
    delete p2;  /* 输出两行：
                   Pegasus 释放了空间...
                   Horse 释放了空间...
            */
    return 0;
}
</code></pre>
<p>7-14 A是A1的虚基类 (10 分)<br>
本题目要求读入3个整数A、B和C，然后按照下列要求完成相关设计：1.定义一个基类A，在其中包含保护的数据成员int i，设计类A的带参构造函数对i进行初始化，定义成员函数display（）显示i值； 2.定义基类A的公有派生类A1，且A是A1的虚基类；A1中包含保护的数据成员int j，设计类A1的构造函数； 3.定义基类A的公有派生类A2，且A是A2的虚基类；A2中包含保护的数据成员int k，设计类A2的构造函数； 4.定义类A3，A3是A1和A2以多继承方式生成的公有派生类，设计类A3的构造函数；定义成员函数disp（）在其中调用display（）函数显示i值，另外输出j和k值； 5.在main（）中定义类A3的1个对象变量，通过输入的3个整数完成对象的创建；调用类A3的成员函数disp（）输出信息。</p>
<p>输入格式:<br>
输入在一行中给出3个绝对值不超过1000的整数A、B和C。</p>
<p>输出格式:<br>
按行输出每个类中的构造函数中的信息和在主函数中调用的对象的成员函数。</p>
<p>输入样例:<br>
在这里给出一组输入。例如：</p>
<p>1 2 3<br>
输出样例:<br>
在这里给出相应的输出。例如：</p>
<p>Call A:i=1<br>
Call A1:i=1<br>
Call A2:i=1<br>
Call A3:i=1<br>
i=1<br>
j=2<br>
k=3</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class A
{
public:
	A(int i1) :i(i1) { cout &lt;&lt; &quot;Call A:i=&quot; &lt;&lt; i &lt;&lt; endl; }
	void display()
	{
		cout &lt;&lt; i &lt;&lt; endl;
	}
protected:
	int i;
};

class A1:virtual public A
{
public:
	A1(int i1,int j) :A(i1),j(j){ cout &lt;&lt; &quot;Call A1:i=&quot; &lt;&lt; i &lt;&lt; endl; }
protected:
	int j;
};

class A2:virtual public A
{
public:
	A2(int i1,int k1):A(i1),k(k1){ cout &lt;&lt; &quot;Call A2:i=&quot; &lt;&lt; i &lt;&lt; endl; }
protected:
	int k;
};

class A3:public A1,public A2
{
public:
	A3(int i1,int j1,int k1):A2(i1,k1),A1(i1,j1),A(i1){ cout &lt;&lt; &quot;Call A3:i=&quot; &lt;&lt; i &lt;&lt; endl; }
	void display()
	{
		cout&lt;&lt;&quot;i=&quot; &lt;&lt; i &lt;&lt; endl;
		cout&lt;&lt;&quot;j=&quot; &lt;&lt; j &lt;&lt; endl;
		cout&lt;&lt;&quot;k=&quot; &lt;&lt; k &lt;&lt; endl;

	}
};
int main()
{
	int a, b, c;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
	A3 a3(a, b, c);
	a3.display();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统实验 ]]></title>
        <id>https://haifengchengguang.github.io/post/cao-zuo-xi-tong-shi-yan/</id>
        <link href="https://haifengchengguang.github.io/post/cao-zuo-xi-tong-shi-yan/">
        </link>
        <updated>2021-04-23T07:20:25.000Z</updated>
        <content type="html"><![CDATA[<p align="right">edit at 23/4/2021</p>
<h2 id="1进程控制实验">1.进程控制实验</h2>
<ul>
<li>这个实验我用了vscode，顺道推荐一波kali linux，自带gcc,pyhon,java环境，用的是kde桌面非常舒服。</li>
</ul>
<p>实验题目</p>
<p>编写一个父子协作进程，父进程创建一个子进程并控制它每隔 3 秒显示一次当前目录中的文件名列表。<br>
实验代码</p>
<p>pctl.h</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt; 
#include &lt;wait.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;signal.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; //进程自定义的键盘中断信号处理函数
 typedef void (*sighandler_t) (int); 
 void sigcat()
 { 
     printf(&quot;%d Process continue\n&quot;,getpid());
     }
</code></pre>
<p>pctl.c</p>
<pre><code class="language-c">#include &quot;pctl.h&quot;
int main( int argc,char* argv[])
{
    int t;
    int pid;
    int status;
    int childpid;
    char *args[]={&quot;/bin/ls&quot;,&quot;-a&quot;,NULL};
    signal(SIGUSR1,(sighandler_t)sigcat);
    pid=fork();
    if(pid&lt;0)
    {
        printf(&quot;Create Process fail!\n&quot;);
    }
    if(pid==0)
    {
        while ((1))
        {
            pause();
            childpid=fork();
            if(childpid&lt;0)
                exit(EXIT_FAILURE);
            if(childpid==0)
               { //printf(&quot;I am child process %d\n&quot;,getpid());
                printf(&quot;child process will Running:\n&quot;);
                status=execve(args[0],args,NULL);}
           
           
            }


        }
    else{
                printf(&quot;I am parent process %d\n&quot;,getpid());
                while (1)
                {
                    /* code */
                    sleep(3);
                    kill(pid,SIGUSR1);
                    printf(&quot;%d prarent sent siganl:\n&quot;,getpid());
                    
                }
    }
    return EXIT_SUCCESS;
}
</code></pre>
<p>编译<br>
<code>gcc -c pctl.c -o pctl.o</code><br>
<code>gcc pctl.o -o pctl</code></p>
<p>运行结果<br>
<img src="https://haifengchengguang.github.io/post-images/1619162601325.png" alt="" loading="lazy"></p>
<h2 id="2进程通信实验">2.进程通信实验</h2>
<ul>
<li>从这个实验开始我用了clion，在linux里非常舒服，https://www.jetbrains.com/clion/download/#section=linux，从官网下载，解压，在命令行中打开clion-2021.1/bin/，./clion.sh 运行clion，激活就可以愉快地使用Clion了，本来打算学一下makefile，但是感觉这个东西学习成本太高，用处并不是很大，clion自带的cmake就很好用，c++项目管理一般用vs,cmke或qmake。</li>
</ul>
<p>实验题目</p>
<p>请编程建立 3 个并发协作进程，它们分别完成 f(x,y)、f(x)、f(y)<br>
f(x,y) = f(x) + f(y)<br>
f(x) = f(x-1) * x (x &gt;1)<br>
f(x)=1 (x=1)<br>
f(y) = f(y-1) + f(y-2) (y&gt; 2)<br>
f(y)=1 (y=1,2）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ffmpeg+qt开发环境搭建]]></title>
        <id>https://haifengchengguang.github.io/post/ffmpeg-kai-fa-huan-jing-da-jian/</id>
        <link href="https://haifengchengguang.github.io/post/ffmpeg-kai-fa-huan-jing-da-jian/">
        </link>
        <updated>2021-04-23T07:13:44.000Z</updated>
        <content type="html"><![CDATA[<p align="right">edit at 23/4/2021</p>
<p>qt creater新建qt widgets application项目，kit selection选择mingw 64-bit，</p>
<p>下载ffmpeg，https://www.gyan.dev/ffmpeg/builds/</p>
<p>下拉，选择https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-full-shared.7z</p>
<p><strong>SHA256:</strong> 4aaf80f0ee78a9eb5a1396742fd51d1624a705bfa7ce263e9b440b8be7db5650</p>
<p>将下载好的文件解压，放到项目文件中</p>
<p>将以下代码复制到.pro文件中</p>
<pre><code>TEMPLATE = app
CONFIG += console c++11
CONFIG -= app_bundle
CONFIG -= qt


INCLUDEPATH += $$PWD/ffmpeg/include

LIBS += $$PWD/ffmpeg/lib/avcodec.lib \
        $$PWD/ffmpeg/lib/avdevice.lib \
        $$PWD/ffmpeg/lib/avfilter.lib \
        $$PWD/ffmpeg/lib/avformat.lib \
        $$PWD/ffmpeg/lib/avutil.lib \
        $$PWD/ffmpeg/lib/postproc.lib \
        $$PWD/ffmpeg/lib/swresample.lib \
        $$PWD/ffmpeg/lib/swscale.lib


LIBS += -L$$PWD/ffmpeg/bin -lavcodec-58
LIBS += -L$$PWD/ffmpeg/bin -lavdevice-58
LIBS += -L$$PWD/ffmpeg/bin -lavformat-58
LIBS += -L$$PWD/ffmpeg/bin -lpostproc-55
LIBS += -L$$PWD/ffmpeg/bin -lswresample-3
LIBS += -L$$PWD/ffmpeg/bin -lswscale-5
</code></pre>
<p>将以下代码复制到main.cpp中</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define __STDC_CONSTANT_MACROS

extern &quot;C&quot;
{
#include &quot;libavcodec/avcodec.h&quot;
};

int main(int argc, char* argv[])
{
    printf(&quot;%s&quot;, avcodec_configuration());
    return 0;
}
</code></pre>
<p>重新打开qt creater</p>
<p>运行</p>
<p>弹出窗口</p>
<pre><code>--enable-gpl --enable-version3 --enable-shared --disable-w32threads --disable-autodetect --enable-fontconfig --enable-iconv --enable-gnutls --enable-libxml2 --enable-gmp --enable-lzma --enable-libsnappy --enable-zlib --enable-libsrt --enable-libssh --enable-libzmq --enable-avisynth --enable-libbluray --enable-libcaca --enable-sdl2 --enable-libdav1d --enable-libzvbi --enable-librav1e --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxvid --enable-libaom --enable-libopenjpeg --enable-libvpx --enable-libass --enable-frei0r --enable-libfreetype --enable-libfribidi --enable-libvidstab --enable-libvmaf --enable-libzimg --enable-amf --enable-cuda-llvm --enable-cuvid --enable-ffnvcodec --enable-nvdec --enable-nvenc --enable-d3d11va --enable-dxva2 --enable-libmfx --enable-libcdio --enable-libgme --enable-libmodplug --enable-libopenmpt --enable-libopencore-amrwb --enable-libmp3lame --enable-libshine --enable-libtheora --enable-libtwolame --enable-libvo-amrwbenc --enable-libilbc --enable-libgsm --enable-libopencore-amrnb --enable-libopus --enable-libspeex --enable-libvorbis --enable-ladspa --enable-libbs2b --enable-libflite --enable-libmysofa --enable-librubberband --enable-libsoxr --enable-chromaprint
</code></pre>
<p>说明环境已经配置好了，可以进行开发了</p>
]]></content>
    </entry>
</feed>