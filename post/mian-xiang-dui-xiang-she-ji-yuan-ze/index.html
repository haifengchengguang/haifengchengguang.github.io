<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>面向对象设计原则 | hrefen</title>
<link rel="shortcut icon" href="https://haifengchengguang.github.io/favicon.ico?v=1678091929164">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://haifengchengguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="面向对象设计原则 | hrefen - Atom Feed" href="https://haifengchengguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-183666884-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-183666884-1');
</script>


    <meta name="description" content="edit at 22/6/2021

Single Responsibility Principle，SRP：单一职责原则
单一职责原则简称 SRP ，顾名思义，就是一个类只负责一个职责。那这个原则有什么用呢，它让类的职责更单一。
Open..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://haifengchengguang.github.io">
  <img class="avatar" src="https://haifengchengguang.github.io/images/avatar.png?v=1678091929164" alt="">
  </a>
  <h1 class="site-title">
    hrefen
  </h1>
  <p class="site-description">
    我很弱，但是我要坚强！绝不让那些为我付出过的人失望！

  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              面向对象设计原则
            </h2>
            <div class="post-info">
              <span>
                2021-05-25
              </span>
              <span>
                5 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p align="right">edit at 22/6/2021</p>
<figure data-type="image" tabindex="1"><img src="https://haifengchengguang.github.io/post-images/1624342406341.png" alt="" loading="lazy"></figure>
<h3 id="single-responsibility-principlesrp单一职责原则">Single Responsibility Principle，SRP：单一职责原则</h3>
<p>单一职责原则简称 SRP ，顾名思义，就是一个类只负责一个职责。那这个原则有什么用呢，它让类的职责更单一。</p>
<h3 id="open-closed-principleocp开闭原则">Open Closed Principle，OCP：开闭原则</h3>
<p>一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭</p>
<h3 id="liskov-substitution-principlelsp里氏替换原则">Liskov Substitution Principle，LSP：里氏替换原则</h3>
<p>如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。</p>
<p>换言之，一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且它根本不能察觉出基类对象和子类对象的区别。</p>
<p>比如，假设有两个类，一个是Base类，另一个是Child类，并且Child类是Base的子类。那么一个方法如果可以接受一个基类对象b的话:method1(Base b)那么它必然可以接受一个子类的对象method1(Child c).</p>
<p>里氏替换原则是继承复用的基石。只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才能真正的被复用，而衍生类也才能够在基类的基础上增加新的行为。</p>
<p>但是需要注意的是，反过来的代换是不能成立的，如果一个软件实体使用的是一个子类的话，那么它不一定适用于基类。如果一个方法method2接受子类对象为参数的话method2(Child c)，那么一般而言不可以有method2(b).</p>
<h3 id="law-of-demeterlod迪米特法则">Law of Demeter，LoD：迪米特法则</h3>
<p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<h3 id="interface-segregation-principleisp接口隔离原则">Interface Segregation Principle，ISP：接口隔离原则</h3>
<p>继承多个接口，使用多个专一的接口代替一个统一的接口。</p>
<h3 id="dependence-inversion-principledip依赖倒置原则">Dependence Inversion Principle，DIP：依赖倒置原则</h3>
<p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。</p>
<h3 id="composite-reuse-principlecrp合成复用原则">Composite Reuse Principle，CRP：合成复用原则</h3>
<p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用这些对象的目的。</p>
<p>如果两个类是“Has-a”关系应使用合成、聚合，如果是“Is-a”关系可使用继承。&quot;Is-A&quot;是严格的分类学意义上定义，意思是一个类是另一个类的&quot;一种&quot;。而&quot;Has-A&quot;则不同，它表示某一个角色具有某一项责任。</p>
<p>什么是合成?什么是聚合</p>
<p>合成（Composition）和聚合（Aggregation）都是关联（Association）的特殊种类。</p>
<p>聚合</p>
<p>聚合用来表示“拥有”关系或者整体与部分的关系。代表部分的对象有可能会被多个代表整体的对象所共享，而且不一定会随着某个代表整体的对象被销毁或破坏而被销毁或破坏，部分的生命周期可以超越整体。例如，班级和学生，当班级删除后，学生还能存在，学生可以被培训机构引用。在设计中, 聚合不应该频繁出现，这样会增大设计的耦合度。</p>
<p>聚合关系UML类图</p>
<pre><code class="language-javascript">class Student {

}

class Classes{

         private Student student;

         publicClasses(Student student){

                   this.student=student;
        }

}
</code></pre>
<p>合成</p>
<p>合成用来表示一种强得多的“拥有”关系。在一个合成关系里，部分和整体的生命周期是一样的。一个合成的新对象完全拥有对其组成部分的支配权，包括它们的创建和湮灭等。使用程序语言的术语来说，合成而成的新对象对组成部分的内存分配、内存释放有绝对的责任。一个合成关系的成分对象是不能与另一个合成关系共享的。</p>
<p>合成关系UML类图</p>
<pre><code class="language-javascript">class Room{

         public Room createRoom(){
                   System.out.println(“创建房间”);
                   returnnew Room();
          } 
 }

class House{

         private Room room;

         public House(){ 
               room=new Room();
          }

         public void createHouse(){
                room.createRoom();
         } 
  }
</code></pre>
<p>换句话说，合成是值的聚合（Aggregation by Value），而一般说的聚合是引用的聚合（Aggregation by Reference）。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#single-responsibility-principlesrp%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99">Single Responsibility Principle，SRP：单一职责原则</a></li>
<li><a href="#open-closed-principleocp%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">Open Closed Principle，OCP：开闭原则</a></li>
<li><a href="#liskov-substitution-principlelsp%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">Liskov Substitution Principle，LSP：里氏替换原则</a></li>
<li><a href="#law-of-demeterlod%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99">Law of Demeter，LoD：迪米特法则</a></li>
<li><a href="#interface-segregation-principleisp%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">Interface Segregation Principle，ISP：接口隔离原则</a></li>
<li><a href="#dependence-inversion-principledip%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99">Dependence Inversion Principle，DIP：依赖倒置原则</a></li>
<li><a href="#composite-reuse-principlecrp%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99">Composite Reuse Principle，CRP：合成复用原则</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://haifengchengguang.github.io/post/c-pta/">
              <h3 class="post-title">
                c++ pta
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '8c2bfbf18727f466152c',
    clientSecret: 'c5406e5093c1fc36f0a94093cd581fe5e82784a3',
    repo: 'haifengchengguang.github.io',
    owner: 'haifengchengguang',
    admin: ['haifengchengguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
   <div>
    <a href="https://gridea.dev/" target="_blank">Powered by Gridea&#65281;</a>
  </div>
  <div>
    <strong><i>你是人间的四月天❤</i></strong>
  <a class="rss" href="https://haifengchengguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
